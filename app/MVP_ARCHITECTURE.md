# MindMend MVP Architecture - Simplified & Focused

## MVP Scope & Philosophy

**Core Value**: AI-powered habit tracking with personalized coaching insights
**MVP Features**: Habit tracking, journal entries, AI-generated insights, weekly summaries
**Tech Philosophy**: Simple, proven technologies that can scale later

### What's IN the MVP
✅ User authentication and profiles  
✅ Habit creation, tracking, and streaks  
✅ Journal entries with mood tracking  
✅ AI insights using OpenAI with user data  
✅ Weekly AI summaries  
✅ Basic analytics dashboard  
✅ Push notifications for check-ins  

### What's OUT of MVP
❌ Custom ML models (use OpenAI directly)  
❌ GraphQL (REST only)  
❌ Vector search/Pinecone (simple text search)  
❌ Community features (focus on personal journey first)  
❌ Advanced analytics/reporting  
❌ Complex microservices (monolith + AI service)  

## Simplified Technology Stack

### Backend
- **Runtime**: Node.js 20+ with TypeScript
- **Framework**: Express.js (simple, well-documented)
- **Database**: PostgreSQL 15+ (single instance)
- **ORM**: Prisma (excellent TypeScript support)
- **Authentication**: Firebase Auth (handles complexity for us)
- **AI**: OpenAI GPT-4 API (no custom models)
- **Caching**: Redis (single instance)
- **Queue**: Bull Queue + Redis (for background AI processing)

### Frontend
- **Mobile**: React Native (existing)
- **Web Dashboard**: Next.js (later phase)

### Infrastructure
- **Cloud**: Railway or Render (simpler than AWS for MVP)
- **Database**: Managed PostgreSQL
- **Redis**: Managed Redis instance
- **File Storage**: Cloudinary (simpler than S3)
- **Monitoring**: Built-in platform monitoring + Sentry

## Simplified Database Schema

```sql
-- Core MVP Tables Only

-- Users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  firebase_uid VARCHAR(128) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  display_name VARCHAR(100),
  timezone VARCHAR(50) DEFAULT 'UTC',
  coach_style VARCHAR(20) DEFAULT 'supportive',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Habits
CREATE TABLE habits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(100) NOT NULL,
  description TEXT,
  habit_type VARCHAR(20) NOT NULL, -- 'avoid' or 'build'
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Habit Events (completions, skips, relapses)
CREATE TABLE habit_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  habit_id UUID REFERENCES habits(id) ON DELETE CASCADE,
  event_type VARCHAR(20) NOT NULL, -- 'completed', 'skipped', 'relapsed'
  notes TEXT,
  occurred_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_habit_events_user_date (user_id, occurred_at)
);

-- Journal Entries
CREATE TABLE journal_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(200),
  content TEXT NOT NULL,
  mood_rating INTEGER, -- 1-10
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- AI Insights (generated by OpenAI)
CREATE TABLE ai_insights (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  insight_type VARCHAR(30) NOT NULL, -- 'weekly_summary', 'daily_tip', 'pattern_detected'
  title VARCHAR(200) NOT NULL,
  content TEXT NOT NULL,
  data_used JSONB, -- what user data was included in the prompt
  was_shown BOOLEAN DEFAULT false,
  shown_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP
);

-- Simple analytics table
CREATE TABLE daily_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  habits_completed INTEGER DEFAULT 0,
  habits_total INTEGER DEFAULT 0,
  journal_entries INTEGER DEFAULT 0,
  avg_mood FLOAT,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id, date)
);
```

## API Architecture - REST Only

### Core REST Endpoints

```typescript
// Authentication (handled by Firebase)
POST /api/auth/verify-token    // Verify Firebase token

// User Profile
GET  /api/user/profile         // Get user profile
PUT  /api/user/profile         // Update profile

// Habits
GET    /api/habits             // Get user's habits
POST   /api/habits             // Create habit
PUT    /api/habits/:id         // Update habit
DELETE /api/habits/:id         // Delete habit

// Habit Events
GET  /api/habits/:id/events    // Get habit history
POST /api/habits/:id/events    // Log completion/skip/relapse

// Streaks (computed on-demand)
GET /api/habits/:id/streak     // Get current streak for habit
GET /api/streaks/summary       // Get all current streaks

// Journal
GET    /api/journal            // Get journal entries (paginated)
POST   /api/journal            // Create entry
PUT    /api/journal/:id        // Update entry
DELETE /api/journal/:id        // Delete entry

// AI Insights
GET  /api/ai/insights          // Get user's insights
POST /api/ai/generate-insight  // Request new insight (async)
GET  /api/ai/weekly-summary    // Get this week's summary

// Analytics
GET /api/analytics/dashboard   // Simple dashboard data
GET /api/analytics/trends      // Basic trend data
```

## Simplified Service Architecture

### Single Backend Service

```typescript
// app.ts - Main Express Application
class MindMendAPI {
  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupErrorHandling();
  }

  private setupRoutes() {
    this.app.use('/api/auth', authRoutes);
    this.app.use('/api/user', userRoutes);
    this.app.use('/api/habits', habitRoutes);
    this.app.use('/api/journal', journalRoutes);
    this.app.use('/api/ai', aiRoutes);
    this.app.use('/api/analytics', analyticsRoutes);
  }
}

// services/aiService.ts - Simple OpenAI Integration
class AIService {
  private openai: OpenAI;

  async generateWeeklySummary(userId: string): Promise<string> {
    // Get user data from last 7 days
    const userData = await this.getUserDataForWeek(userId);
    
    const prompt = `
    You are a supportive habit coach. Generate a weekly summary for this user:
    
    Habits this week: ${JSON.stringify(userData.habits)}
    Journal entries: ${JSON.stringify(userData.journalEntries)}
    Mood trends: ${JSON.stringify(userData.moodTrends)}
    
    Provide:
    1. A motivational message about their progress
    2. Key insights about patterns you notice
    3. One specific recommendation for next week
    
    Keep it encouraging and actionable. Max 200 words.
    `;

    const response = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 300,
      temperature: 0.7
    });

    return response.choices[0].message.content;
  }

  async generateDailyInsight(userId: string): Promise<string> {
    const recentData = await this.getRecentUserData(userId);
    
    const prompt = `
    As a habit coach, provide a brief daily insight for this user:
    
    Recent habit completions: ${JSON.stringify(recentData.habits)}
    Recent journal entry: "${recentData.lastJournalEntry?.content}"
    Current mood: ${recentData.lastMood}/10
    
    Give one encouraging observation or tip. Max 50 words.
    `;

    const response = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 80,
      temperature: 0.8
    });

    return response.choices[0].message.content;
  }

  private async getUserDataForWeek(userId: string) {
    // Simple queries to get last 7 days of data
    const habits = await prisma.habitEvent.findMany({
      where: {
        user_id: userId,
        occurred_at: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
      },
      include: { habit: true }
    });

    const journalEntries = await prisma.journalEntry.findMany({
      where: {
        user_id: userId,
        created_at: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
      }
    });

    // Calculate simple metrics
    const completedHabits = habits.filter(h => h.event_type === 'completed').length;
    const totalHabits = habits.length;
    const avgMood = journalEntries.reduce((sum, e) => sum + (e.mood_rating || 5), 0) / journalEntries.length;

    return { habits, journalEntries, completedHabits, totalHabits, avgMood };
  }
}

// Background job processing
class JobProcessor {
  async processQueue() {
    // Daily stats calculation
    this.queue.add('calculate-daily-stats', {}, {
      repeat: { cron: '0 1 * * *' } // 1 AM daily
    });

    // Weekly summary generation
    this.queue.add('generate-weekly-summaries', {}, {
      repeat: { cron: '0 18 * * 0' } // 6 PM Sundays
    });
  }

  async calculateDailyStats(userId: string, date: Date) {
    // Simple aggregation of daily data
    const habits = await this.getHabitsForDay(userId, date);
    const journal = await this.getJournalForDay(userId, date);
    
    await prisma.dailyStats.upsert({
      where: { 
        user_id_date: { user_id: userId, date } 
      },
      update: {
        habits_completed: habits.completed,
        habits_total: habits.total,
        journal_entries: journal.count,
        avg_mood: journal.avgMood
      },
      create: {
        user_id: userId,
        date,
        habits_completed: habits.completed,
        habits_total: habits.total,
        journal_entries: journal.count,
        avg_mood: journal.avgMood
      }
    });
  }
}
```

## Streak Calculation (Simplified)

```typescript
// Simple streak calculation without materialized views
class StreakCalculator {
  async getCurrentStreak(userId: string, habitId: string): Promise<number> {
    // Get habit events in reverse chronological order
    const events = await prisma.habitEvent.findMany({
      where: { user_id: userId, habit_id: habitId },
      orderBy: { occurred_at: 'desc' }
    });

    let streak = 0;
    let currentDate = new Date();
    currentDate.setHours(0, 0, 0, 0); // Start of today

    for (const event of events) {
      const eventDate = new Date(event.occurred_at);
      eventDate.setHours(0, 0, 0, 0);

      // Check if event is from current streak date
      if (eventDate.getTime() === currentDate.getTime()) {
        if (event.event_type === 'completed') {
          streak++;
          currentDate.setDate(currentDate.getDate() - 1); // Move to previous day
        } else {
          break; // Streak broken
        }
      } else if (eventDate.getTime() < currentDate.getTime()) {
        // Gap in habit tracking - check if it's just one day
        const daysDiff = Math.floor((currentDate.getTime() - eventDate.getTime()) / (1000 * 60 * 60 * 24));
        if (daysDiff === 1 && event.event_type === 'completed') {
          streak++;
          currentDate = new Date(eventDate);
          currentDate.setDate(currentDate.getDate() - 1);
        } else {
          break; // Streak broken
        }
      }
    }

    return streak;
  }

  async getAllCurrentStreaks(userId: string): Promise<Array<{habitId: string, streak: number, title: string}>> {
    const habits = await prisma.habit.findMany({
      where: { user_id: userId, is_active: true }
    });

    const streaks = await Promise.all(
      habits.map(async habit => ({
        habitId: habit.id,
        title: habit.title,
        streak: await this.getCurrentStreak(userId, habit.id)
      }))
    );

    return streaks;
  }
}
```

## Weekly AI Summary Integration

```typescript
// Simplified weekly summary system
class WeeklySummaryService {
  async shouldShowSummary(userId: string): Promise<boolean> {
    const lastSummary = await prisma.aiInsight.findFirst({
      where: {
        user_id: userId,
        insight_type: 'weekly_summary'
      },
      orderBy: { created_at: 'desc' }
    });

    if (!lastSummary) return true;

    // Show if it's been more than 6 days since last summary
    const daysSince = Math.floor((Date.now() - lastSummary.created_at.getTime()) / (1000 * 60 * 60 * 24));
    return daysSince >= 6;
  }

  async generateAndStoreSummary(userId: string): Promise<void> {
    const summary = await this.aiService.generateWeeklySummary(userId);
    const userData = await this.aiService.getUserDataForWeek(userId);

    await prisma.aiInsight.create({
      data: {
        user_id: userId,
        insight_type: 'weekly_summary',
        title: 'Your Weekly Progress',
        content: summary,
        data_used: userData,
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      }
    });
  }

  async getLatestSummary(userId: string): Promise<any> {
    return await prisma.aiInsight.findFirst({
      where: {
        user_id: userId,
        insight_type: 'weekly_summary'
      },
      orderBy: { created_at: 'desc' }
    });
  }
}
```

## Deployment Architecture

### Simple Single-Instance Deployment

```yaml
# docker-compose.yml for development/small production
version: '3.8'
services:
  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - FIREBASE_CONFIG=${FIREBASE_CONFIG}
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=mindmend
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

## MVP Implementation Plan (8 Weeks)

### Week 1-2: Core Backend Setup
- [ ] Express.js API with TypeScript
- [ ] PostgreSQL + Prisma setup
- [ ] Firebase Auth integration
- [ ] Basic CRUD for users and habits

### Week 3-4: Habit Tracking & Streaks
- [ ] Habit events API
- [ ] Streak calculation logic
- [ ] Basic analytics endpoints
- [ ] Daily stats background job

### Week 5-6: Journal & AI Integration
- [ ] Journal CRUD operations
- [ ] OpenAI service integration
- [ ] Daily insight generation
- [ ] Weekly summary system

### Week 7: Mobile Integration & Testing
- [ ] Connect React Native app to API
- [ ] Test all critical user flows
- [ ] Basic error handling and validation
- [ ] Performance optimization

### Week 8: Deployment & Polish
- [ ] Production deployment setup
- [ ] Monitoring and error tracking
- [ ] API documentation
- [ ] Final testing and bug fixes

## Cost Estimation (MVP)

### Development (8 weeks)
- **Single Full-Stack Developer**: ~$40k-60k

### Monthly Operating Costs
- **Railway/Render**: $50-100/month
- **Managed PostgreSQL**: $20-50/month  
- **Managed Redis**: $15-30/month
- **OpenAI API**: $50-200/month (usage-based)
- **Firebase Auth**: $0-25/month
- **Sentry (Error Tracking)**: $0-26/month
- **Total**: ~$135-430/month

### Key Benefits of This Approach
✅ **Faster MVP delivery** (8 weeks vs 16 weeks)  
✅ **Lower development cost** ($50k vs $100k+)  
✅ **Proven, simple technologies**  
✅ **Easy to understand and maintain**  
✅ **Can scale later when needed**  
✅ **Focus on core user value**  

This simplified architecture removes the complexity while keeping all the core features that make MindMend valuable: habit tracking, streaks, journaling, and AI-powered insights.